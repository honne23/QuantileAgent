import torch.nn as nnfrom Network.NoisyLinear import NoisyLinearclass DuelingNetwork(nn.Module):    def __init__(self,  hidden_size, num_actions):        super(DuelingNetwork, self).__init__()                self.num_actions = num_actions        self.feature_layer = nn.Sequential(            nn.Conv2d(in_channels = 4, out_channels=32, kernel_size=8, stride = 4),             nn.ReLU(),            nn.Conv2d(in_channels = 32, out_channels=64, kernel_size=4, stride = 2),             nn.ReLU(),            nn.Conv2d(in_channels = 64, out_channels=64, kernel_size=3, stride = 1),             nn.ReLU(),            nn.Flatten()        )                self.advantage_layer = nn.Sequential(            NoisyLinear(7*7*64, hidden_size),            nn.ReLU(),            NoisyLinear(hidden_size, num_actions)        )        self.value_layer = nn.Sequential(            NoisyLinear(7*7*64, hidden_size),            nn.ReLU(),            NoisyLinear(hidden_size, 1)        )    def forward(self, x):        out = self.feature_layer(x)        adv = self.advantage_layer(out)        val = self.value_layer(out)        return val + (adv - adv.mean(dim=1, keepdim=True))        def reset_noise(self):        for i in [*self.advantage_layer, *self.value_layer]:            if isinstance(i, NoisyLinear):                i.sample_noise()